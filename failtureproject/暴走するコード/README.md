# 暴走するコード

## 問題概要
SPI通信で温度センサーの温度を取得し、計算した結果をprintfで表示するプログラム「ShowTempareture」を実行したところ

 * システムがハングして再起動を繰り返す
 * printfにて浮動小数点値が表示できない

という問題が起こった。

### コード暴走問題について
#### 問題箇所の特定
浮動小数点演算を今回初めて利用したため、そのあたりに問題があるのではないかと、あたりをつけた。
そしてプロジェクトにデバッグのためのコードを追加し、アセンブリ命令を1命令ずつ実行していったところ、以下のところでシステムがハングすることが発覚した。
```
8114:	ee073a90 	vmov	s15, r3
```
このvmov命令はFPU（浮動小数点演算ユニット）を使ったアセンブリ命令である。
Cのコードでは以下の演算を行っていた部分に当たる。
```
temp = rawtemp / 128.0;
```
問題はやはり浮動小数点演算だった。

#### なぜ再起動したか
ハングした後に再起動する理由は、何らかの問題が起こり例外が発生しているのではないかとあたりを付けた。
このプロジェクトは「03_newlib」のコードをベースに開発を行っている。つまりベクタテーブルは全く設定されていない。
この状態で例外が起こるとメモリの0x00付近に飛び、ブートシーケンスに従って0x8000にとび、結果として再起動が行われる。

これを確かめるために、「xx_interrupt」のコードをベースに「vfptest」を作成した。
このプロジェクトは何らかの例外によりhangupに飛ぶと、すぐにその時のCPSRの値をprintfで表示する。
表示された値を見れば、現在のCPUモード、つまりどの例外が起こったかがわかるはずだ。

このプログラムの実行結果は次のようになった。
```
CPSR: 0x800001db
```
下位5bitは11011なので、これはつまり未定義モード（未定義命令が実行された）である。
Raspberry PiにはFPUが搭載されているため、vmov命令はなぜ未定義になってしまったのか。


#### 問題解決
TwitterやRaspberry Pi日本ユーザーグループなどに質問をしたところ、次のようなアドバイスを頂いた。
```
「VFPやNEON命令は、どこかのレジスタで有効にしなければ、未定義として処理されてしまうはず」
```
このアドバイスを元に、ARM1176JZF-Sのマニュアルを読むと、FPEXCというレジスタがその役割をになっていることがわかった。

またBareMetal Raspberry Piの第1人者であるDavid Welchさんのリポジトリにも、float03というVFPを利用したプロジェクトが存在する。
このコードを参考にすると、VFPを有効にするには次のコードをSVCモードで実行する必要があった。
```
mrc p15, 0, r0, c1, c0, 2
orr r0,r0,#0x300000 ;@ single precision
orr r0,r0,#0xC00000 ;@ double precision
mcr p15, 0, r0, c1, c0, 2
mov r0,#0x40000000
fmxr fpexc,r0
```

#### 対応
FPUを利用するための内容を、スタートアップについての解説部に詳しく書くと、その後の章への道のりが長くなってしまう。
そのため最初はVFPを使わず、soft floatを利用して開発するように、文章とソースコードを変更した。
具体的な変更箇所はMakefileのCFLAGSをこのようにした。
```
CFLAGS= -mfloat-abi=hard -mlittle-endian
↓
CFLAGS= -mfloat-abi=soft -mlittle-endian
```
VFPを利用した演算については、のちの章にて解説を行うことにする。


### ptinfにて浮動小数点値が表示できない問題について
```
printf("%f",0.01);
```
のようなプログラムを実行すると、
```
f
```
と表示されてしまう問題に直面した。
調べてみると、newlibはデフォルトで浮動小数点値の表示ができないようになっているそうだ（とても大きなメモリを食うため）。

crosstool-ngの設定の中に、「FLOATやDOUBLEを利用する」というチェックボックスがあったので、これを有効にしたところ、問題が解決した。
